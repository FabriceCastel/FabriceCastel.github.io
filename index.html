<html>

<head>
<title>f_castel</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="styles.css">
<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
  precision mediump float;

  const bool PERF_DEBUG = false;
  const float NUMBER_OF_SCENES = 2.0;
  const float MAX_DISTANCE = 150.0;
  const float IMAGE_WIDTH = 400.0;
  const float EPSILON = 0.1;
  const float PI = 3.14159265359;
  const int MAX_ITERATIONS = 65000; // ints on mobile go span -2^16, 2^16
  const vec3 light1 = vec3(-300.0, 200.0, -1035.0);
  const vec3 light2 = vec3(-600.0, -200.0, -400.0);
  vec3 baseMaterial = vec3(0.92);
  const vec3 specMaterial = vec3(1.0);
  const vec3 ambientMaterial = vec3(0.04);
  const float shininess = 8000.0;

  float fov = 50.0;
  float fovx = PI * fov / 360.0;
  float fovy = fovx * 1.0; // height/width = 1.0 in the square canvas
  float ulen = tan(fovx);
  float vlen = tan(fovy);
  const vec3 camPos = vec3(0.0, 0.0, -120.0);
  const vec3 camDir = vec3(0.0, 0.0, 1.0);
  const vec3 camUp = vec3(0.0, 1.0, 0.0);

  float camOrbitSpeed = 20.0;

  // Inputs
  varying vec2 uv;
  uniform float t; // time as frame number
  uniform float currentScene; // one scene per int, interpolate in-between
  uniform sampler2D u_image; // reflection texture

  // Utils
  float max(float a, float b, float c){
    return max(a, max(b, c));
  }

  float max(float a, float b, float c, float d){
    return max(max(a, b), max(c, d));
  }

  float min(float a, float b, float c){
    return min(min(a, b), c);
  }

  float min(float a, float b, float c, float d){
    return min(min(a, b), min(c, d));
  }

  mat4 rotationMatrix(vec3 axis, float angle){
      axis = normalize(axis);
      float s = sin(angle);
      float c = cos(angle);
      float oc = 1.0 - c;
      
      return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                  oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                  oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                  0.0,                                0.0,                                0.0,                                1.0);
  }

  vec3 rotate(vec3 vec, mat4 rmat){
    vec4 vf = vec4(vec, 0.0);
    vf = rmat * vf;
    return vec3(vf[0], vf[1], vf[2]);
  }


  float intersectReflectionPlane(vec3 p, vec3 ray){
    // dot the plane normal with the ray direction
    float denom = dot(ray, vec3(1.0, 0.0, 0.0));
    if(abs(denom) > EPSILON){
        float t = (-dot(p, vec3(1.0, 0.0, 0.0)) - 65.0) / denom;
        return t;
    }
    return -1.0;
  }

  // Primitive distance functions
  float sphere(vec3 p, vec3 orig, float r){
    return length(p-orig) - r;
  }

  float baseOrigCube(vec3 p, float hdim){
    return max(abs(p[0]) - hdim, abs(p[1]) - hdim, abs(p[2]) - hdim);
  }

  float cube(vec3 p, vec3 orig, float dim){
    float hdim = dim/2.0;
    vec3 modP = abs(p - orig);
    if(modP[0] > hdim || modP[1] > hdim || modP[2] > hdim){
      vec3 sph = vec3(min(modP[0], hdim), min(modP[1], hdim), min(modP[2], hdim));
      return length(modP - sph);
    } else {
      return baseOrigCube(modP, hdim);
    }
  }

  // drad is the radius of the tube, trad is the radius of the doughnut
  float torus(vec3 p, vec3 orig, float drad, float trad){
    vec2 q = vec2(length(p.xz) - trad, p[2]);
    return length(q) - drad;
  }

  // Combination operators
  float cSmooth(float a, float b, float r){
    float res = exp(-r*a) + exp(-r*b);
    return -log(res)/r;
  }

  float cSmooth(float a, float b, float c, float d, float r){
    return cSmooth(cSmooth(a, b, r), cSmooth(c, d, r), r);
  }

  float cBool(float a, float b){
    return max(a, b);
  }

  // Scene distance functions
  float sDist1(vec3 p){
    float base = sphere(p, vec3(0.0, 0.0, 0.0), 25.0 + 5.0*sin(0.007*t+0.35));
    float s1 = sphere(p, vec3(7.0*cos(0.05*t)+11.3, -9.0, 4.0*sin(0.7+0.08*t)+4.0), 19.0);
    float s2 = sphere(p, vec3(12.0*sin(0.018*t)+11.3, 14.0, 4.0*sin(0.2+0.032*t)+4.0), 15.0);
    float s3 = sphere(p, vec3(10.0*sin(0.06-0.02*t)+16.0, 14.0*cos(0.013*t)-4.0, 4.0), 20.0);
    float s4 = sphere(p, vec3(10.0, 14.0*cos(0.013*t)-4.0, -10.0*sin(0.03*t)+5.0), 22.0);
    
    p = -p;
    float s5 = sphere(p, vec3(7.0*cos(0.09*t)+11.3, -9.0, 4.0*sin(0.7+0.08*t)+4.0), 19.0);
    float s6 = sphere(p, vec3(12.0*sin(0.43-0.018*t)+11.3, 9.0, 4.0*sin(0.8+0.032*t)+4.0), 4.0*cos(0.008*t)+21.0);
    float s7 = sphere(p, vec3(10.0*sin(0.02*t)+16.0, 14.0*cos(0.3-0.013*t)-4.0, 4.0), 20.0);
    float s8 = sphere(p, vec3(10.0, 9.0*cos(0.4+0.013*t)+4.0, -10.0*sin(0.06*t)-6.0), 15.0);
    
    float g1 = cSmooth(s1, s2, 0.2);
    float g2 = cSmooth(s3, s4, 0.2);
    float g3 = cSmooth(s5, s6, 0.2);
    float g4 = cSmooth(s7, s8, 0.2);
    float group = cSmooth(g1, g2, g3, g4, 0.3);
    
    float blob = cSmooth(base, group, 0.5);
    return blob;
  }

  float sDist2(vec3 p){
    p = 0.8 * p;
    float nt = 0.01*t;
    vec4 np1 = vec4(p, 0.0);
    vec4 np2 = np1;
    vec4 np3 = np1;
    vec4 np4 = np1;
    np1 = np1 * rotationMatrix(vec3(0.0, 1.0, 0.0), -nt);
    np2 = np1 * rotationMatrix(vec3(1.0, 0.0, 0.0), -nt*0.9);
    np3 = np1 * rotationMatrix(vec3(0.0, 0.4, 1.0), nt*1.24);
    np4 = np4 * rotationMatrix(vec3(-0.6, 0.7, 0.1), nt*1.67);
    vec3 npp1 = vec3(np1[0], np1[1], np1[2]);
    vec3 npp2 = vec3(np2[0], np2[1], np2[2]);
    vec3 npp3 = vec3(np3[0], np3[1], np3[2]);
    vec3 npp4 = vec3(np4[0], np4[1], np3[2]);
    return max(cube(npp3, vec3(0.0, 0.0, 0.0), 40.0), 
      min(cube(npp1, vec3(0.0, 0.0, 0.0), 40.0),
        cube(npp2, vec3(0.0, 0.0, 0.0), 40.0),
        cube(npp4, vec3(0.0, 0.0, 0.0), 36.0)));
  }

  float sDist3(vec3 p){
    return torus(p, vec3(0.0), 6.0, 30.0);
  }

  float sDist(vec3 p){


    return sDist2(p);


    float cscene = mod(currentScene, NUMBER_OF_SCENES);
    if(cscene == 0.0)
      return sDist1(p);
    else if(cscene <= 1.0)
      return sDist2(p);
    else
      return sDist3(p);
  }
  
  // 6 point sample normal
  vec3 sNormal(vec3 p){
    vec3 a = p + EPSILON*vec3(-1,  0,  0);
    vec3 b = p + EPSILON*vec3( 1,  0,  0);
    vec3 c = p + EPSILON*vec3( 0, -1,  0);
    vec3 d = p + EPSILON*vec3( 0,  1,  0);
    vec3 e = p + EPSILON*vec3( 0,  0, -1);
    vec3 f = p + EPSILON*vec3( 0,  0,  1);
    return
      normalize(
        sDist(a)*(a-p) +
        sDist(b)*(b-p) +
        sDist(c)*(c-p) +
        sDist(d)*(d-p) +
        sDist(e)*(e-p) +
        sDist(f)*(f-p));
  }

  // Blinn-Phong shader
  vec3 blinnPhongShade(vec3 p, vec3 eye, vec3 light){
    vec3 n = sNormal(p);
    vec3 eyeToPoint = normalize(p - eye);
    vec3 pointToLight = normalize(light - p);
    if(dot(n, eyeToPoint) > 0.0) return ambientMaterial;
    else {
      float sdn = max(dot(pointToLight, n), 0.0);
      vec3 diffuse = baseMaterial * sdn;
      float cosAngInsicende = dot(n, pointToLight);
      vec3 halfAngle = light - p + eye - p;
      float halfAngleLen = length(halfAngle);
      halfAngle = normalize(normalize(halfAngle) * 1.0/halfAngleLen);
      float blinnTerm = dot(halfAngle, n);
      if(blinnTerm < 0.0 || cosAngInsicende == 0.0) blinnTerm = 0.0;
      else if(blinnTerm > 1.0) blinnTerm = 1.0;
      return ambientMaterial + diffuse + specMaterial*pow(blinnTerm, shininess);
    }
  }
  vec3 blinnPhongShade(vec3 p, vec3 eye){
    return blinnPhongShade(p, eye, light1);// + blinnPhongShade(p, eye, light2);
  }

  // scene texture function
  vec3 sTexture(vec3 p){
    float d = length(p + vec3(13.0*sin(0.01*t), -14.0*cos(0.009*t), sin(0.006*t)*8.0));
    const float dRange = 28.0; // repeat pattern every 10 units
    float range_min = 0.92 + (sin(0.02*t) -1.0)*0.1;
    const float range_max = 0.92;
    float range_span = range_max - range_min;
    const float n3 = 1.0/3.0;
    float x = mod(d, dRange) / dRange;
    vec3 rainbow = vec3(0.0, 0.0, 0.0);
    for(int i = 0; i < 3; i++){
      rainbow[i] = mix(range_span, 0.0, min(x*3.0, (1.0-x)*3.0, 1.0));
      x = mod(x + n3, 1.0);
    }
    return rainbow+vec3(range_min);
  }

  vec4 traceRay(vec3 pixel, vec3 ray){
    float d = 0.0;
    float delta = 0.0;
    for(int i = 0; i < MAX_ITERATIONS; i++){ // can't use while loops in WebGL shaders
      delta = sDist(pixel + d*ray);
      if(delta <= EPSILON){
        vec3 inter = pixel + d*ray;
        baseMaterial = sTexture(inter);
        vec3 refRay = reflect(normalize(inter - pixel), sNormal(inter));
        float t = intersectReflectionPlane(inter, refRay);
        if(t > 0.0){
          vec3 refProj = inter + t*refRay;
          vec2 refUV = vec2(refProj[2], -refProj[1]) / 60.0 + vec2(0.45, 0.1);
          refUV = refUV * 0.7;
          if(abs(refUV[0]) <= 1.0 && abs(refUV[1]) <= 1.0){
            vec3 reflectionKD = texture2D(u_image, refUV+vec2(0.5, 0.5) / 2.0).rgb;
            if(reflectionKD != vec3(1.0)){
              vec3 V = -ray;
              vec3 H = (V + refRay) / (length(V + refRay));
              float refWeight = max(0.0, 1.0 - abs(pow(dot(H, V)+0.14, 1.0)));//0.95;
              baseMaterial = reflectionKD * refWeight + baseMaterial * (1.0-refWeight);
            }
          }
        }
        return vec4(pow(blinnPhongShade(pixel + d*ray, camPos), vec3(1.0/2.2)), 1.0);
      }
      d = d + delta;
      if(d >= MAX_DISTANCE){
        break;
      }
    }
    return vec4(1.0, 1.0, 1.0, 0.0);
  }

  void main(void) {
    gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
    // Lazy bum SSAA, doesn't even take care of the jaggies >:(
    for(float u = 0.0; u < 3.9; u += 1.0){ // sketch counter for arithmetic
      for(float v = 0.0; v < 3.9; v += 1.0){
        float uoffset = 0.5*(u/2.0 - 1.0)/IMAGE_WIDTH;
        float voffset = 0.5*(v/2.0 - 1.0)/IMAGE_WIDTH;
        vec2 adjUV = (uv+vec2(uoffset, voffset))*2.0 - vec2(1.0, 1.0);
        vec3 nright = normalize(cross(camUp, camDir));
        vec3 nup = normalize(cross(nright, camDir));
        vec3 dir = normalize(camDir);
        vec3 pixel = camPos + dir + nright*adjUV[0]*ulen + nup*adjUV[1]*vlen;
        vec3 ray = normalize(pixel - camPos);
        gl_FragColor += (1.0 / 16.0) * traceRay(pixel, ray);
      }
    }
  }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
  precision mediump float;
  varying vec2 uv;
  attribute vec3 aVertexPosition;
  uniform mat4 uMVMatrix;
  uniform mat4 uPMatrix;
  void main(void) {
    uv = vec2(aVertexPosition[0], 1.0 - aVertexPosition[1]);
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
  }
</script>

<script type="text/javascript" src="avatar.js"></script>
<script type="text/javascript" src="initGL.js"></script>
</head>

<body onload="webGLStart(); animateAvatar();" class="fadein">
  <h1 style="margin-bottom:0px;">fabrice_castel</h1>
  <canvas id="canvas" style="border: none; margin-left: auto; margin-right: auto; display: block;" width="400" height="400"></canvas>
  <ul style="margin-top:0px;">
    <li><a href="projects.html">$(projects)</a></li>
    <li><a href="blog.html">__blog__.cpp</a></li>
    <li>. . .</li>
    <li><a href="mailto:fabrice.castel@hotmail.com">contactInformation.sendEmail()</a></li>
  </ul>
  <div id="landingPageAvatarContainer">
    <img src="assets/avatar_idle.png" class="avatar" id="landingPageAvatar"/>
  </div>
</body>

</html>