<html>

<head>
<title>f_castel</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../../styles.css">
</head>


<body>
<div class="blogContainer">
  <h2>Finishing Touches for the Site</h2>
  <h3>May 10th 2015</h3>
  <h3><a href="../../blog.html">(Take me back to the Blog section!)</a></h3>

  <p>I've spent a good part of my weekend working on this website and I'm now trying to finish up the landing page. At this point I've created a character sprite and white blob animation running on a sphere-tracing algorithm inside of a WebGL fragment shader (fun times). The idea is to make the character walk over to the blob and have the blob show his reflection. This is where I'm at:</p>

  <img src="starting_point.png" class="outlinedImage"/>

  <p>The next step I'll be taking is the one that's likeliest to fail; (if you're going to fail, do it fast so you can move on to the next thing!) getting the character reflection up and running. For this I'll be using <a href="http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter07.html">environment mapping</a> along with a uniform variable in my WebGL shader to keep track of the character's state (distance from the blob, which frame of the walking/standing animation is currently displayed...). I'll also need to pass the various sprites into the shader so the shader knows what it's meant to be reflecting.</p>

  <p>Let's start with loading the textures into the shader. First, we'll declare a new variable <b>uniform sampler2D u_image</b> in the fragment shader. I got this from a lot of example code and can't honestly say how or why this works. It seems to me that the underlying framework "knows" this variable name is supposed to be bound to the texture. If anyone can shed some light on how this works, feel free to shoot me an email about it.</p>

  <p>(5 hours later...)</p>

  <p>It turns out getting a texture into my shader was far more painful than expected. The core issue had to do with Image.onLoad callbacks acting like a bunch of fools and WebGL freaking out about the texture being invalid. In the end I resorted to encoding the image in base64 to embed it directly in the page, bypassing these issues. I would generally advise against this as it might make your page's load times skyrocket, but in this case the texture is a single 32x32 image so it gets a pass. ALRIGHT THEN, here's the glorious texture loaded up and displayed in the GL canvas.</p>

  <img src="texture_loaded.png" class="outlinedImage"/>

  <p>Here's the code I wound up with:</p>

  <pre><code>function webGLStart() {
    var canvas = document.getElementById("canvas");
    initGL(canvas);
    initShaders();
    initBuffers();
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.enable(gl.DEPTH_TEST);
    
    texture = gl.createTexture();
    image = new Image();
    image.src = "data:image/png;base64,iVB [...] YII=";
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

    drawScene();
}</code></pre>

  <p>Good good, making progress. This is taking longer than expected, thankfully I'm in no rush. Next up is adding reflective rays in the fragment shader sphere tracer code. The easiest way of implementing this is to use the <b>R=I-2N(Nâ‹…I)</b> formula. Here, <b>R</b> is the ray reflecting off the surface that we want to calculate, <b>I</b> is the incident ray (the ray that goes from the camera to the surface) and <b>N</b> is the surface normal. This function is already provided to us via the <b>reflect(I, N)</b> API in GLSL.</p>

  <p>Now, we want the reflection to only come from the left side of the blob. We'll assume the rest of the environment reflects pure white. In order to do this, we'll determine the plane-ray intersection between the reflected ray and the <b>x=-200</b> plane, then map some range of coordinates on that plane to the texture. The code to find such an intersection looks a little something like this:</p>

<pre><code>float intersectReflectionPlane(vec3 p, vec3 ray){
    // dot the plane normal with the ray direction
    float denom = dot(ray, vec3(1.0, 0.0, 0.0));
    if(abs(denom) > EPSILON){
        float t = (-dot(p, vec3(1.0, 0.0, 0.0)) - 100.0) / denom;
        return t;
    }
    return -1.0;
}</code></pre>

  <p>Here I'm returning a <b>t</b> value for the intersection test, meaning you need to add the reflected ray <b>t</b> times to the intersection point <b>p</b> in order to hit the <b>x=-100</b> plane. Now my shader code for valid surface intersections looks like this:</p>

  <pre><code>
vec3 refRay = reflect(normalize(inter - pixel), sNormal(inter));
float t = intersectReflectionPlane(inter, refRay);
if(t > 0.0){
    vec3 refProj = inter + t*refRay;
    vec2 refUV = vec2(-refProj[2], -refProj[1]) / 500.0;
    if(abs(refUV[0]) <= 1.0 && abs(refUV[1]) <= 1.0)
        baseMaterial = texture2D(u_image, refUV+vec2(0.5, 0.5) / 2.0).rgb;
}
gl_FragColor = vec4(pow(blinnPhongShade(pixel + d*ray, camPos), vec3(1.0/2.2)), 1.0);
</code></pre>

  <p>And with these latest changes this is all starting to come together! There's clearly a few issues to address here. For starters, the reflected colours don't take into account the reflection angle; in order to make this more physically accurate we will have to account for this with <a href="http://en.wikipedia.org/wiki/Fresnel_equations">Fresnel Equations</a>. Then there's the character's distance that remains unaccounted for, irritating aliasing artifacts, the ability to apply different textures for each animation frame, getting rid of the white square around the character's reflection... TL;DR there's still a lot to do, but I'm happy with the way this is turning out! :)</p>

  <img src="reflections_working.png" class="outlinedImage"/>

  <p>I'll come back to this to give it another round of polish when I've got some time on my hands.</p>

</div>
</body>

</html>